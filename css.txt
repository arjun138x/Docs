Basics
----------------
  1. CSS Basics  

    - What is CSS?  
      CSS (Cascading Style Sheets) is a stylesheet language used to control the presentation of HTML documents. 
      It helps in designing web pages by specifying colors, layouts, fonts, and animations.  

    - Types of CSS (Inline, Internal, External) 
      1. Inline CSS – Applied directly within an HTML element using the `style` attribute.  
        <p style="color: blue; font-size: 16px;">This is inline CSS</p>

      2. Internal CSS – Defined inside a `<style>` tag within the HTML file.  
        <style>
            p {
                color: red;
                  font-size: 18px;
            }
        </style>

      3. External CSS – Written in a separate `.css` file and linked to an HTML document.  
        <link rel="stylesheet" href="styles.css">
        styles.css
        p {
            color: green;
            font-size: 20px;
        }

    - CSS Syntax  
      - A CSS rule consists of a selector and a declaration block.  
        selector {
            property: value;
        }

        Example:  
          h1 {
              color: blue;
              font-size: 24px;
          }

    - Colors in CSS (Named, Hex, RGB, HSL)
      - Named Colors: Predefined color names like `red`, `blue`, `green`, etc.  
        p {
            color: red;
        }

      - Hexadecimal (`#RRGGBB`): A six-digit hex code representing Red, Green, and Blue (RGB) values.  
        p {
            color: #ff5733; /* Orange */
        }

        - Shorter version: `#f53` (equivalent to `#ff5533`)  

      - RGB (`rgb(r, g, b)`): ses values between 0 and 255 for each color channel.  
        p {
            color: rgb(255, 87, 51); /* Same as #ff5733 */
        }

        - `rgb(0, 0, 0)` → Black  
        - `rgb(255, 255, 255)` → White  

      - RGBA (`rgba(r, g, b, a)`): Same as RGB but includes an alpha (opacity) value from `0` (fully transparent) to `1` (fully opaque).  
        p {
            color: rgba(255, 87, 51, 0.5); /* 50% transparent */
        }

      - HSL (`hsl(hue, saturation, lightness)`)  
        - Hue (`0-360`) → Defines color (0 = red, 120 = green, 240 = blue).  
        - Saturation (`0-100%`) → Intensity of the color.  
        - Lightness (`0-100%`) → Darkness or brightness.  
        
        p {
            color: hsl(30, 100%, 50%); /* Orange */
        }
        
        - `hsl(0, 100%, 50%)` → Red  
        - `hsl(240, 100%, 50%)` → Blue  

      - HSLA (`hsla(h, s, l, a)`)  
        Same as HSL but with opacity.  
        p {
            color: hsla(30, 100%, 50%, 0.5);
        }


  2. Selectors & Specificity: CSS selectors target specific HTML elements to apply styles.  

    - Basic Selectors (`element`, `.class`, `#id`) 
      - Universal Selector (`*`) – Applies styles to all elements.  
        * {
            margin: 0;
            padding: 0;
        }

      - Element Selector – Targets elements by their tag name.  
        h1 {
            color: red;
        }

      - Class Selector (`.`) – Targets elements with a specific class.  
        .highlight {
            background-color: yellow;
        }

      - ID Selector (``) – Targets a specific element with a unique ID.  
        #main-title {
            font-size: 24px;
        }

        Let's go into detail on these topics:  

    - Attribute Selectors (`[type="text"]`, `[disabled]`): CSS attribute selectors allow you to target elements based on their attributes.  

      - Basic Attribute Selectors  
        - `[attribute]` → Selects elements that have a specified attribute.  
          [disabled] {
              opacity: 0.5;
          }

          - Targets all elements with the `disabled` attribute.

        - `[attribute="value"]` → Selects elements where the attribute has an exact value.  
          input[type="text"] {
              border: 1px solid blue;
          }

          - Targets only `<input>` elements with `type="text"`.

        - `[attribute~="value"]` → Selects elements where the attribute contains the exact word as a value.  
          [class~="button"] {
              background-color: green;
          }
          
          - Targets elements where `class` contains `"button"` as a separate word (e.g., `class="button primary"`).

        - `[attribute^="value"]` → Selects elements where the attribute starts with a specific value.  
          a[href^="https://"] {
              color: green;
          }

          - Targets links that start with `"https://"`.

        - `[attribute$="value"]` → Selects elements where the attribute ends with a specific value.  
          img[src$=".jpg"] {
              border-radius: 10px;
          }
          
          - Targets images with `.jpg` extension.

        - `[attribute*="value"]` → Selects elements where the attribute contains a specific substring.  
          div[class*="container"] {
              padding: 20px;
          }
          
          - Targets any element whose class name contains `"container"` (e.g., `class="main-container"`).  

        ---

    - Grouping & Combinators (`>`, `+`, `~`, `,`): Combinators allow you to define relationships between selectors.

      - Grouping Selectors (` , `): You can apply the same styles to multiple elements using a comma:  
        h1, h2, h3 {
            color: blue;
        }
        - This targets all `<h1>`, `<h2>`, and `<h3>` elements.

      - Descendant Selector (` ` - Space): Selects elements that are inside another element.  
        div p {
            color: red;
        }
        - Targets all `<p>` elements that are inside a `<div>`.

      - Child Selector (`>`): Selects elements that are direct children of a specified parent.  
        div > p {
            font-weight: bold;
        }
        - Targets `<p>` elements that are direct children of a `<div>` (not nested further).

      - Adjacent Sibling Selector (`+`): Selects an element that immediately follows another element.  
        h1 + p {
            color: grey;
        }
        - Targets the first `<p>` right after an `<h1>`.

      - General Sibling Selector (`~`): Selects all siblings after a specified element.  
        h1 ~ p {
            font-style: italic;
        }
        - All `<p>` elements that come after an `<h1>` (not necessarily immediately after) will be italicized.

        ---

    - Pseudo-classes (`:hover`, `:focus`, `:nth-child(n)`)  

      - Hover & Focus States
        - `:hover` – When the user hovers over an element.  
          
          button:hover {
              background-color: green;
          }

          - Changes the button’s background when hovered.

        - `:focus` – When an element is focused (e.g., an input field is clicked).  
          
          input:focus {
              border-color: blue;
          }

      - Nth-child Variants  
        - `:nth-child(n)` – Selects the nth child of a parent.  
          
          li:nth-child(2) {
              color: red;
          }
          
        - Makes the second `<li>` red.

        - `:nth-child(odd)` / `:nth-child(even)`  
          
          tr:nth-child(odd) {
              background-color: #f0f0f0;
          }
        
        - Colors alternate table rows.

        - `:first-child` / `:last-child`  
          
          p:first-child {
              font-weight: bold;
          }

      - Other Common Pseudo-classes
        - `:not(selector)` – Excludes elements that match the selector.  
          
          p:not(.special) {
              color: grey;
          }

        - Targets `<p>` elements that do not have the class `special`.

        - `:checked` – Matches checked checkboxes or radio buttons.  
          
          input[type="checkbox"]:checked {
              background-color: green;
          }

    - Pseudo-elements (`::before`, `::after`)  

      - Pseudo-elements allow you to style specific parts of an element.

        - `::before` inserts content before the actual content.  
          
          p::before {
              content: "👉 ";
              color: red;
          }

        - Adds an emoji before every `<p>`.

        - `::after` inserts content after an element.  
          
          p::after {
              content: " ✨";
          }

        - Other Pseudo-elements:-
          - `::first-letter` – Styles the first letter of an element.  
            
            p::first-letter {
                font-size: 2em;
                color: blue;
            }

          - `::first-line` – Styles only the first line of text.  
            
            p::first-line {
                font-weight: bold;
            }
            
          - `::selection` – Styles selected text.  
            
            ::selection {
                background: yellow;
                color: black;
            }
            
    - Specificity & Inheritance  

      - CSS Specificity Rules: When multiple CSS rules apply to the same element, specificity determines which one wins.

        - Specificity Calculation  
          1. Inline styles → `1000`  
              <p style="color: red;">Red</p>

          2. ID selectors → `100`  
            #heading {
                color: blue;
            }
          
          3. Class, attribute selectors, pseudo-classes → `10`  
            .title {
                color: green;
            }
          
          4. Element and pseudo-elements → `1`  
            p {
                color: black;
            }
          
        - Example of Specificity Conflicts
          
          h1 { color: black; }           /* Specificity = 1 */
          .title { color: blue; }        /* Specificity = 10 */
          #main-title { color: red; }    /* Specificity = 100 */
          
          - The final color of `h1 id="main-title" class="title"` will be red (highest specificity).

      - Inheritance
        - Some properties are inherited (e.g., `color`, `font-family`).  
        - Some aren’t inherited (e.g., `margin`, `padding`).  
        - You can force inheritance using `inherit`:  
          p {
              color: inherit;
          }
          
        - `initial` resets to default:  
          p {
              color: initial;
          }
          
        - `unset` removes styles (acts as `inherit` for inherited properties, `initial` for others).  
          
          p {
              color: unset;
          }


  3. Box Model  

    - Content, Padding, Border, Margin (The Box Model): Every HTML element is represented as a rectangular box in CSS. 
      The Box Model defines how an element's dimensions and spacing work.  

      - Structure of the Box Model  
        
        +-----------------------------+  <- Margin
        |                             |
        |  +-----------------------+  |  <- Border
        |  |                       |  |  
        |  |   +---------------+   |  |  <- Padding
        |  |   |   Content     |   |  |
        |  |   +---------------+   |  |
        |  |                       |  |
        |  +-----------------------+  |
        |                             |
        +-----------------------------+

      - Content  
        - This is the actual content inside the element (text, images, etc.).  
        - The width & height of an element by default apply only to the content.  

        div {
            width: 200px;
            height: 100px;
        }

      - Padding  
        - The space between content and the border.  
        - Adds space inside an element.  
        - Can be applied to all sides individually or together.  

        div {
            padding: 20px; /* 20px padding on all sides */
        }

        /* Individual padding */
        div {
            padding-top: 10px;
            padding-right: 15px;
            padding-bottom: 20px;
            padding-left: 25px;
        }

        - You can also use shorthand:  
          padding: 10px 15px 20px 25px; /* Top Right Bottom Left */

      - Border  
        - The outer edge of the element.  
        - Affects the total size of the element.  

        div {
            border: 5px solid black;
        }
        
        You can control the border style, width, and color:  
        
        border: 2px dashed red; /* Dashed red border */
        border: 3px dotted blue; /* Dotted blue border */

      - Margin  
        - The space outside an element.  
        - Creates space between elements.  

        div {
            margin: 20px; /* 20px margin on all sides */
        }

        Shorthand:
          margin: 10px 15px 20px 25px; /* Top Right Bottom Left */

        -✅ Auto Margin (Centering an Element)  
        To center a block element:  
          div {
              width: 200px;
              margin: 0 auto;
          }

    - `box-sizing` (content-box vs border-box): Defines how the total width and height of an element are calculated.  

      - Default (`content-box`)  
        - Width & height do NOT include `padding` and `border`.  
        - The actual size is larger than the defined width.  

        div {
            width: 200px;
            padding: 20px;
            border: 5px solid black;
            box-sizing: content-box;
        }

        - Final size = 200px (content) + 40px (padding) + 10px (border) = 250px  

      - `border-box` (Recommended!)  
        - Width & height include `padding` and `border`.  
        - The total size remains fixed (content area shrinks to fit).  

        div {
            width: 200px;
            padding: 20px;
            border: 5px solid black;
            box-sizing: border-box;
        }
        
        - Final size = 200px (stays the same!) ✅  

      -Global Fix (Best Practice): To avoid layout issues, apply `border-box` globally:  
        * {
            box-sizing: border-box;
        }
      
    - `overflow` (`visible`, `hidden`, `scroll`, `auto`): Controls how content behaves when it overflows the container.  

      - `visible` (Default): Content overflows outside the element.  
        div {
            overflow: visible;
        }
      
        - Not recommended for fixed-size containers.

      - `hidden`: Content that overflows is cut off (not visible).  
        div {
            overflow: hidden;
        }
      
        - Useful when you don't want scrollbars.

      - `scroll`: Adds both horizontal & vertical scrollbars even if not needed.  
        div {
            overflow: scroll;
        }
        
        - Forces scrollbars.

      - `auto` (Recommended for Dynamic Content): Scrollbars appear only when needed.  
        div {
            overflow: auto;
        }
        
        - Best choice for responsive layouts.

      - Bonus: `overflow-x` & `overflow-y`
        - Control horizontal & vertical overflow separately.  
        div {
            overflow-x: scroll; /* Only horizontal scrolling */
            overflow-y: hidden; /* Hide vertical overflow */
        }

      - Final Thoughts
        - The Box Model defines how elements are sized.  
        - `border-box` ensures predictable layouts.  
        - `overflow` helps manage content inside containers.  


  4. Layout & Positioning  
    - `z-index` (stacking elements)  
    - `float` and `clear`  
    - `visibility` vs `display: none`  


    - `display` (`block`, `inline`, `inline-block`, `flex`, `grid`, `none`): The `display` property determines how an element is rendered in the layout.

      - `block`
        - Takes up the full width available.
        - Starts on a new line.
        - Height and width can be set.  

        - Example elements: `<div>`, `<p>`, `<h1>-<h6>`, `<section>`, `<article>`, etc.  
        
        div {
            display: block;
            width: 200px;
            height: 100px;
            background-color: lightblue;
        }

      - `inline`
        - Does NOT start on a new line.
        - Takes up only the necessary width.
        - Height & width cannot be changed.  

        - Example elements: `<span>`, `<a>`, `<strong>`, `<em>`.  
        
        span {
            display: inline;
            background-color: yellow;
            width: 100px; /* ❌ Won't work */
        }
        
        - Use when styling text within a paragraph.

      - `inline-block`
        - Behaves like `inline` but allows setting width & height.  
        - Stays on the same line as inline elements.  

        button {
            display: inline-block;
            width: 120px;
            height: 40px;
            background-color: blue;
            color: white;
        }
        
        - Use for buttons, images, navigation links.

      - `flex` (Flexible Box Layout)
        - Enables flexible layouts.
        - Uses parent-child relationship (`display: flex` on parent).  
        
        .container {
            display: flex;
            justify-content: space-between;
        }
        
        - Best for responsive layouts.

      - `grid` (CSS Grid Layout)
        - Creates a grid-based layout with rows & columns.  
        - Uses parent-child relationship (`display: grid` on parent).  

        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
        }
        
        - Best for complex layouts.

      - `none`
        - Hides the element completely (removes it from the DOM).  

        
        div {
            display: none;
        }
        
        - Unlike `visibility: hidden`, it removes the element from layout.

    - `position` (`static`, `relative`, `absolute`, `fixed`, `sticky`): Defines how an element is positioned in the document.

       - `static` (Default): The element is positioned normally (default flow).  
        
        div {
            position: static;
        }
        
        - No special positioning.

      - `relative`: Positioned relative to itself (from its original position).  
        
        div {
            position: relative;
            top: 20px;
            left: 30px;
        }
        
        - Useful for small adjustments.

      - `absolute`: Positioned relative to the nearest positioned (non-static) ancestor.  
        
        .parent {
            position: relative;
        }
        .child {
            position: absolute;
            top: 10px;
            left: 20px;
        }
        
        - Ignores normal document flow.

        ---

      - `fixed`: Stays in place even when scrolling.  
        
        div {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: black;
        }
        
        - Used for sticky headers, floating buttons.

      - `sticky`: Acts like `relative` until it reaches a scroll position, then acts like `fixed`.  
        
        div {
            position: sticky;
            top: 50px;
        }
        
        - Best for sticky navigation bars.

    - `z-index` (Stacking Order)
      - Defines layer order of elements.
      - Higher `z-index` values appear above lower values.

      .box1 {
          position: absolute;
          z-index: 1;
          background-color: red;
      }
      .box2 {
          position: absolute;
          z-index: 2;
          background-color: blue;
      }
      
      - Higher `z-index` brings elements to the front.

    - `float` & `clear`
      - `float` (Floating Elements): Moves elements to the left or right, allowing text to wrap around.

        img {
            float: right;
        }
        
        - Used for text wrapping.

      - `clear` (Stop Floating): Prevents elements from wrapping around floated elements.

        div {
            clear: both;
        }
        
        - Use `clear: both;` to fix layout issues.

    - `visibility` vs `display: none`
        | Property              | Effect |
        |-----------------------|--------|
        | `display: none;`      | Hides element completely (removes from DOM). |
        | `visibility: hidden;` | Hides element but it still takes up space. |

        
        div {
            display: none; /* Removes the element */
        }
        
        div {
            visibility: hidden; /* Hidden but still occupies space */
        }
        
        - Use `display: none;` to remove elements.  
        - Use `visibility: hidden;` for temporary hiding without affecting layout.

    - Final Thoughts
        - `display`, `position`, `z-index`, `float`, and `visibility` control layout & visibility.
        - `flex` & `grid` are best for modern layouts.
        - Use `position: sticky` for fixed navigation.


  5. Responsive Design  

    - Media Queries (`@media`): Media queries allow you to create responsive designs by applying different CSS rules based on screen size, resolution, or device type.  

      - Basic Syntax
        @media (max-width: 600px) {
            body {
                background-color: lightblue;
            }
        }
        
        - If screen width is 600px or smaller, the background becomes light blue.

      - Common Breakpoints: Breakpoints define when the layout should change.  
        
        @media (max-width: 480px) { /* Phones */ }
        @media (min-width: 481px) and (max-width: 768px) { /* Tablets */ }
        @media (min-width: 769px) and (max-width: 1024px) { /* Small Laptops */ }
        @media (min-width: 1025px) { /* Desktops */ }
        
        -Adjusts layout for different devices.

      - Orientation (Portrait/Landscape)
        
        @media (orientation: portrait) {
            body {
                background-color: pink;
            }
        }
        @media (orientation: landscape) {
            body {
                background-color: lightgreen;
            }
        }
        
        - Different styles based on screen orientation.

    - Units (`px`, `%`, `em`, `rem`, `vh`, `vw`): CSS has different units for defining sizes.  

      - | Unit  | Description |
        |-------|------------|
        | `px`  | Fixed size (not responsive) |
        | `%`   | Relative to parent element |
        | `em`  | Relative to parent's font-size |
        | `rem` | Relative to root (`html`) font-size |
        | `vh`  | 1% of viewport height |
        | `vw`  | 1% of viewport width |

      - Examples
        
        div {
            width: 50%;   /* 50% of parent width */
            font-size: 2em;   /* 2x the parent font size */
            height: 100vh;  /* Full height of viewport */
        }
        
        - Use `rem` for fonts, `vh/vw` for full-screen elements.

    - Flexbox (Flexible Layouts): Flexbox helps in creating dynamic, responsive layouts.

      - Basic Setup
        
        .container {
            display: flex;
        }

      - Key Properties
        | Property | Description |
        |----------|------------|
        | `display: flex;` | Enables flexbox |
        | `flex-direction: row/column;` | Main axis direction |
        | `justify-content: flex-start/center/space-between;` | Aligns items on main axis |
        | `align-items: flex-start/center/stretch;` | Aligns items on cross axis |

        Example
        
          .container {
              display: flex;
              justify-content: space-between;
              align-items: center;
          }
          
          - Best for navigation bars, card layouts.

    - CSS Grid (Two-Dimensional Layouts): CSS Grid is best for complex layouts.

      - Basic Grid Setup
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
        }

      - Key Properties
        | Property | Description |
        |----------|------------|
        | `grid-template-columns` | Defines number of columns |
        | `grid-template-rows` | Defines number of rows |
        | `gap` | Space between grid items |
        | `grid-column: span 2;` | Makes an item span multiple columns |

        - Example
        
          .container {
              display: grid;
              grid-template-columns: repeat(3, 1fr);
              gap: 10px;
          }
          
          - Best for full-page layouts, dashboards.

    - Mobile-First vs Desktop-First Approach  

      - Mobile-First (Recommended ✅)
        - Start with small screens, then add styles for larger screens.
        - Uses `min-width` media queries.

        
        /* Default styles (Mobile) */
        body {
            font-size: 14px;
        }

        /* Larger screens */
        @media (min-width: 768px) {
            body {
                font-size: 18px;
            }
        }
        
        - Best for performance and responsiveness.

      - Desktop-First
        - Start with large screens, then add styles for smaller screens.
        - Uses `max-width` media queries.

        
        /* Default styles (Desktop) */
        body {
            font-size: 18px;
        }

        /* Smaller screens */
        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }
        }
        
        - Best for legacy designs, but not as scalable.

    - Final Thoughts
      - Use `@media` queries for responsiveness.
      - `rem` & `%` make layouts more flexible.
      - Flexbox is best for one-dimensional layouts.
      - Grid is best for two-dimensional layouts.
      - Mobile-first is the best practice for modern web development.


  6. Typography & Fonts  
    - Typography plays a crucial role in web design, affecting readability, aesthetics, and user experience. 
      Here’s a deep dive into CSS typography properties:

    - Font Families (`serif`, `sans-serif`, `monospace`): The `font-family` property specifies the type of font to be used.

      -Font Categories  
        - Serif – Fonts with small decorative strokes at the ends of letters.  
          - Examples: `Times New Roman`, `Georgia`, `Garamond`.  
          - Best for: Formal documents, newspapers.  
          
        - Sans-serif – Clean fonts without decorative strokes.  
          - Examples: `Arial`, `Helvetica`, `Verdana`.  
          - Best for: Web content, modern UI.  

        - Monospace – Every letter has equal width.  
          - Examples: `Courier New`, `Consolas`, `Menlo`.  
          - Best for: Code snippets, terminal displays.  

        - Example:

          body {
              font-family: Arial, sans-serif;
          }
          
        - Always provide a fallback font in case the primary font isn’t available.

    - `@font-face` (Custom Fonts): The `@font-face` rule allows you to use custom fonts.

      - Example:

        @font-face {
            font-family: 'CustomFont';
            src: url('custom-font.woff2') format('woff2'),
                url('custom-font.woff') format('woff');
        }

        p {
            font-family: 'CustomFont', sans-serif;
        }
        
        - Use WOFF2 format for better performance.

    - `font-size`, `font-weight`, `font-style`

      - `font-size` (Text Size): Defines the size of the font.

        - Units:
          - `px` (Absolute) → `font-size: 16px;`
          - `em` (Relative to parent) → `font-size: 1.2em;`
          - `rem` (Relative to root `<html>`) → `font-size: 1.2rem;`
          - `%` (Relative to parent) → `font-size: 120%;`

        - Example:
          h1 {
              font-size: 2rem; /* 2x the root font size */
          }
          
        - Use `rem` for scalability.

      - `font-weight` (Thickness): Controls the boldness of text.

        | Value        | Effect |
        |-------------|--------|
        | `100`-`900` | Light to Extra Bold |
        | `normal`    | Default weight (400) |
        | `bold`      | Equivalent to 700 |
        | `bolder`    | One level heavier than parent |

        - Example:
          p {
              font-weight: bold;
          }
        
        - Use numeric values for more control.

      - `font-style` (Italic & Oblique): Defines the font appearance.

        | Value      | Effect |
        |------------|--------|
        | `normal`   | Default (no styling) |
        | `italic`   | Italic text |
        | `oblique`  | Slanted text |

        - Example:

          p {
              font-style: italic;
          }

        - Use italic for emphasis.

    - `line-height` (Line Spacing): Controls the vertical spacing between lines of text.

      - Values:
        - Number (multiplier) → `line-height: 1.5;` (1.5x font size)
        - Percentage → `line-height: 150%;`
        - Fixed Unit → `line-height: 24px;`

      - Example:

        p {
            font-size: 16px;
            line-height: 1.6;
        }
      
      - Use unitless values (1.5, 1.6) for better scalability.

    - Text Alignment (`text-align`, `text-justify`)

      - `text-align` (Horizontal Alignment): Aligns text inside a block.

        | Value         | Effect |
        |--------------|--------|
        | `left`       | Aligns text to the left (default) |
        | `right`      | Aligns text to the right |
        | `center`     | Centers text |
        | `justify`    | Stretches text to fit width |

        - Example:
          p {
              text-align: center;
          }

        - Use `text-align: justify;` for professional articles.

      - `text-justify` (Control Justification): Works with `text-align: justify;`.

        | Value    | Effect |
        |----------|--------|
        | `auto`   | Default spacing |
        | `inter-word` | Spaces words evenly |
        | `inter-character` | Spaces characters evenly |

        - Example:
          p {
              text-align: justify;
              text-justify: inter-word;
          }

        - Use `inter-word` for readability.

    - Letter & Word Spacing: These properties adjust spacing between letters and words.

      - `letter-spacing`: Controls spacing between characters.
        - Example:
          h1 {
              letter-spacing: 2px;
          }

        - Use for headings to improve readability.

      - `word-spacing`: Controls spacing between words.

        - Example:
          p {
              word-spacing: 4px;
          }

        - Use for justified text to improve readability.

    - Final Thoughts
        - Use `@font-face` for custom fonts.
        - `rem` & `em` are best for scalable typography.
        - Set `line-height` to 1.5 or higher for readability.
        - Use `letter-spacing` & `word-spacing` for better text flow.
        - Use `text-align: justify` for professional documents.


  7. CSS Background, Border, and Box Shadow Properties 

    - Background properties (`background-color`, `background-image`, `background-size`, `background-position`, `background-repeat`)  
      - CSS background properties allow you to control the background color, images, and their behavior.

      - `background-color` (Solid Backgrounds): Sets the background color of an element.

        - Example:
          body {
              background-color: lightblue;
          }
        
        - Supports color values like `#ff0000`, `rgb(255, 0, 0)`, `hsl(0, 100%, 50%)`.

      - `background-image` (Using Images): Sets an image as the background.

        - Example:
          body {
              background-image: url('background.jpg');
          }
        
        - Use high-quality, optimized images.

      - `background-size` (Scaling Images): Defines how the background image is scaled.

        | Value        | Effect |
        |-------------|--------|
        | `auto`      | Default size |
        | `cover`     | Covers entire area (cropped if needed) |
        | `contain`   | Fits inside element (may not fill completely) |
        | `100% 100%` | Stretches to fit |

        - Example:
          body {
              background-image: url('background.jpg');
              background-size: cover;
          }
        
        - Use `cover` for full-page backgrounds.

      - `background-position` (Image Alignment): Controls the position of the background image.

        | Value        | Effect |
        |-------------|--------|
        | `left top`  | Top-left corner |
        | `center center` | Centered image |
        | `right bottom` | Bottom-right corner |
        | `50% 50%`  | Precise positioning |

        - Example:
          body {
              background-image: url('bg.jpg');
              background-position: center;
          }

        - Use `background-position: center;` to align images neatly.

      - `background-repeat` (Repeating Backgrounds): Defines how the background image repeats.

        | Value        | Effect |
        |-------------|--------|
        | `repeat`    | Repeats both horizontally & vertically (default) |
        | `repeat-x`  | Repeats horizontally |
        | `repeat-y`  | Repeats vertically |
        | `no-repeat` | No repetition |

        - Example:
          body {
              background-image: url('bg.jpg');
              background-repeat: no-repeat;
          }
        
        - Use `no-repeat` for single-background images.

      - `background` (Shorthand): All background properties in one.

        - Example:
          body {
              background: url('bg.jpg') no-repeat center/cover;
          }
        
        - Saves space and improves readability.

    - Border properties (`border-radius`, `border-style`, `border-width`): Borders define the outline of elements.

      - `border-style` (Border Type): Defines the border appearance.

        | Value    | Effect |
        |----------|--------|
        | `solid`  | Solid line |
        | `dotted` | Dotted border |
        | `dashed` | Dashed border |
        | `double` | Double-line border |

        - Example:
          div {
              border-style: solid;
          }

      - `border-width` (Thickness): Sets the thickness of the border.

        - Example:
          div {
              border-width: 5px;
          }
        
        - Can use specific sides like `border-top-width: 2px;`.

      - `border-color` (Border Color): Defines the color of the border.

        - Example:
          div {
              border-color: red;
          }
        
        - Accepts `hex`, `rgb()`, and `hsl()` values.

      - `border-radius` (Rounded Corners): Rounds the corners of an element.

        | Value        | Effect |
        |-------------|--------|
        | `0px`       | No rounding (default) |
        | `10px`      | Slightly rounded |
        | `50%`       | Fully rounded (circle) |

        - Example:
          button {
              border-radius: 10px;
          }
        
        - Use `border-radius: 50%;` for circular images.

      -`border` (Shorthand): Combines `border-width`, `border-style`, and `border-color`.

        - Example:
          div {
              border: 2px solid black;
          }
        
        - Saves space and improves readability.

    - Box Shadows (`box-shadow`): Creates shadows around elements for depth effects.

      - Syntax: box-shadow: h-offset v-offset blur spread color;
        
      - h-offset → Horizontal shadow position (+ right, - left).
      - v-offset → Vertical shadow position (+ down, - up).
      - blur → Blurriness of shadow.
      - spread → Shadow size expansion.
      - color → Shadow color.

      - Basic Shadow
        - Example:
          div {
              box-shadow: 5px 5px 10px gray;
          }
        
        - Creates a subtle 3D effect.

      - Inner Shadow
        - Example:
          div {
              box-shadow: inset 3px 3px 5px rgba(0, 0, 0, 0.3);
          }
        
        - `inset` makes the shadow appear inside the element.

       - Multiple Shadows
        - Example:
          div {
              box-shadow: 3px 3px 5px red, -3px -3px 5px blue;
          }
        
        - Layer multiple shadows for complex effects.

    - Final Thoughts
      - Use `background-size: cover;` for full-page backgrounds.
      - `border-radius: 50%` makes perfect circles.
      - Use `box-shadow` for modern UI depth.
      - Shorthand properties save space.


  8. CSS Transitions, Animations, and Transformations  

    - CSS provides powerful tools for adding smooth transitions, animations, and transformations to enhance user experience. 
      Let’s break down each concept in detail.

    - CSS Transitions (`transition`, `transition-duration`, `transition-timing-function`): CSS transitions allow you to smoothly change CSS properties over time.

      - `transition` (Shorthand Property)
        - Syntax: transition: property duration timing-function delay;

        | Property         | Description |
        |-----------------|-------------|
        | `property`      | The CSS property to animate (`all` for everything). |
        | `duration`      | Time in `s` or `ms` (`0.5s`, `200ms`). |
        | `timing-function` | Defines animation speed (`ease`, `linear`, etc.). |
        | `delay`         | Delay before animation starts. |

        - Example:
          button {
              background-color: blue;
              transition: background-color 0.5s ease-in-out;
          }

          button:hover {
              background-color: red;
          }
        
        - When hovered, the button smoothly changes from blue to red.

      - `transition-duration` (Set Duration): Defines how long the transition lasts.

        - Example:
          div {
              width: 100px;
              transition-duration: 1s;
          }
        
        - If a width change occurs, it takes 1 second to complete.

      - `transition-timing-function` (Control Speed Curve): Determines the acceleration pattern.

        | Value        | Effect |
        |-------------|--------|
        | `ease` (default) | Starts slow, speeds up, then slows down. |
        | `linear`   | Constant speed. |
        | `ease-in`  | Starts slow, then speeds up. |
        | `ease-out` | Starts fast, then slows down. |
        | `ease-in-out` | Slow start & end, fast in the middle. |
        | `cubic-bezier(x, y, x2, y2)` | Custom speed curve. |

        - Example:
          div {
              transition: width 2s cubic-bezier(0.42, 0, 0.58, 1);
          }
        
        - Custom animation curves for fine-tuned control.

        ---

    - CSS Animations (`@keyframes`, `animation-name`, `animation-duration`): Unlike transitions, CSS animations allow for more complex movement and multiple keyframes.

      - `@keyframes` (Define Animations): Keyframes define different stages of an animation.

        - Example:
          @keyframes fadeIn {
              from {
                  opacity: 0;
              }
              to {
                  opacity: 1;
              }
          }

          div {
              animation: fadeIn 2s ease-in-out;
          }
        
        - Fades in over 2 seconds.

      - `animation` (Shorthand Property)
        - animation: name duration timing-function delay iteration-count direction;

        | Property             | Description |
        |----------------------|-------------|
        | `name`              | Name of the `@keyframes`. |
        | `duration`          | How long it lasts. |
        | `timing-function`   | Acceleration pattern. |
        | `delay`             | When it starts. |
        | `iteration-count`   | How many times it repeats (`infinite` for loop). |
        | `direction`         | `normal`, `reverse`, `alternate`, `alternate-reverse`. |

        - Example:
          @keyframes bounce {
              0% { transform: translateY(0); }
              50% { transform: translateY(-50px); }
              100% { transform: translateY(0); }
          }

          div {
              animation: bounce 1s infinite alternate ease-in-out;
          }
        
        - The div bounces forever.

      - `animation-delay` (Start Delay): Delays animation execution.

        - Example:
          div {
              animation: fadeIn 2s ease-in-out 1s; /* Starts after 1 second */
          }
        
        - Use delays for staggered effects.

      - `animation-iteration-count` (Repeat Animation): Defines how many times an animation plays.

        | Value        | Effect |
        |-------------|--------|
        | `1`         | Runs once (default). |
        | `infinite`  | Runs forever. |
        | `3`         | Runs 3 times. |

        - Example:
          div {
              animation: shake 0.5s 3;
          }
        
        - Runs the shake animation 3 times.

      - `animation-direction` (Reverse or Alternate)
        | Value        | Effect |
        |-------------|--------|
        | `normal`    | Runs forward. |
        | `reverse`   | Runs backward. |
        | `alternate` | Runs forward, then backward. |
        | `alternate-reverse` | Runs backward, then forward. |

        - Example:
          div {
              animation: bounce 2s infinite alternate;
          }
        
        - Moves up, then down repeatedly.

    - CSS Transformations: CSS transformations allow you to rotate, scale, move, and skew elements.

      - `rotate` (Spin Elements): Rotates elements.

        | Value        | Effect |
        |-------------|--------|
        | `rotate(45deg)`  | Rotates 45 degrees clockwise. |
        | `rotate(-90deg)` | Rotates 90 degrees counterclockwise. |

        - Example:
          div {
              transform: rotate(45deg);
          }
        
        - Use for rotating icons, text, or images.

      - `scale` (Resize Elements): Scales elements up or down.

        | Value        | Effect |
        |-------------|--------|
        | `scale(1.5)` | Increases size by 1.5x. |
        | `scale(0.5)` | Shrinks by 50%. |
        | `scaleX(2)`  | Doubles width. |
        | `scaleY(0.8)` | Shrinks height. |

        - Example:
          div:hover {
              transform: scale(1.2);
          }
        
        - Grows when hovered.

      - `translate` (Move Elements)
        Moves an element without affecting layout.

        | Value        | Effect |
        |-------------|--------|
        | `translateX(50px)`  | Moves right by 50px. |
        | `translateY(-20px)` | Moves up by 20px. |
        | `translate(50px, -20px)` | Moves right and up. |

        - Example:
          div {
              transform: translate(20px, 10px);
          }
        
        - Moves 20px right, 10px down.

      - `skew` (Tilt Elements): Skews elements horizontally or vertically.

        | Value        | Effect |
        |-------------|--------|
        | `skewX(30deg)`  | Skews horizontally. |
        | `skewY(15deg)`  | Skews vertically. |
        | `skew(30deg, 15deg)` | Skews in both directions. |

        - Example:
          div {
              transform: skew(20deg);
          }
        
        - Creates a slanted effect.

      - Combining Transformations: You can combine multiple transformations.

        - Example:
          div {
              transform: translate(50px, 20px) scale(1.2) rotate(45deg);
          }
        
        - Moves right, scales up, and rotates at the same time.

    - Final Thoughts
      - Use `transition` for simple effects.  
      - Use `animation` for complex movements.  
      - Use `transform` for creative layout effects.  
      - Combine properties for smooth interactions.  


  9. Advanced CSS Features: Variables, Clipping, Masking, Filters, and Performance Optimization  

    - These advanced CSS features allow for dynamic styling, visual effects, and performance optimizations. Let’s break them down in detail.

    - CSS Variables (`--variable-name`, `var(--variable-name)`): CSS variables (also called custom properties) allow you to store reusable values and use them throughout your CSS.

      - Declaring a CSS Variable: CSS variables are defined using `--variable-name` inside a `:root` or any selector.

        Example:
          :root {
              --primary-color: #ff5733;
              --font-size: 16px;
          }

          button {
              background-color: var(--primary-color);
              font-size: var(--font-size);
          }
        
        - Benefits:
          - Easy theme customization (e.g., light & dark mode).  
          - Easier maintenance (change once, update everywhere).  

      - Fallback Values: If the variable is not defined, you can set a fallback value.

        Example:
          button {
              background-color: var(--secondary-color, blue); /* Uses blue if undefined */
          }
        
        - Prevents errors when a variable is missing.

    - `clip-path` (Clipping Elements)" The `clip-path` property is used to define a visible area of an element, hiding the rest.

      - Clipping with Basic Shapes
        | Shape | Syntax |
        |-------|--------|
        | Circle | `clip-path: circle(50% at center);` |
        | Ellipse | `clip-path: ellipse(50% 30% at center);` |
        | Polygon | `clip-path: polygon(50% 0%, 100% 100%, 0% 100%);` |

        Example:
          img {
              clip-path: circle(50%);
          }
        
        - Creates circular images without `border-radius`.

      - Complex Clipping with `polygon()`
        Example:
          div {
              clip-path: polygon(0% 0%, 100% 50%, 0% 100%);
          }
        
        - Great for creative layouts & UI designs.

    - `mask-image` (Masking Elements): The `mask-image` property controls the visibility of elements using an image or gradient.

      - Using a Gradient Mask
        Example:
          div {
              mask-image: linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0));
          }
        
        - Creates a fading effect from top to bottom.

      - Using an Image as a Mask
        Example:
          div {
              mask-image: url('mask.png');
          }
        
        - Creates non-rectangular shapes with transparent effects.

    - `filter` (`blur`, `brightness`, `contrast`)  
      - The `filter` property adds visual effects like blur, brightness, and contrast.

        | Filter | Description |
        |--------|-------------|
        | `blur(px)` | Blurs the element. |
        | `brightness(%)` | Adjusts brightness. |
        | `contrast(%)` | Adjusts contrast. |
        | `grayscale(%)` | Converts to grayscale. |
        | `sepia(%)` | Adds a sepia tone. |

      - Blur Effect
        Example:
          img {
              filter: blur(5px);
          }
        
        - Great for background blur effects.

      - Brightness & Contrast
        Example:
          img {
              filter: brightness(120%) contrast(90%);
          }
        
        - Enhances image visibility dynamically.

      - Combining Filters: You can combine multiple filters for advanced effects.

        Example:
          img {
              filter: grayscale(50%) blur(2px) brightness(120%);
          }
        
        - Used for creative photo effects.

    - `will-change` (Performance Optimization): The `will-change` property tells the browser which properties will change, allowing it to optimize performance.

      - Using `will-change` for Smooth Transitions
        Example:
          button {
              will-change: transform, opacity;
          }
        
        - Helps the browser optimize animations for better performance.

      - When to Use `will-change`
        - Use only when necessary (overuse can waste resources).  
        - Best for frequently changing elements (hover effects, animations).  

    - Final Thoughts
      - Use CSS variables for easier theme management.  
      - Use `clip-path` for creative layouts and non-rectangular shapes.  
      - Use `mask-image` for transparency effects.  
      - Use `filter` for image enhancements and UI effects.  
      - Use `will-change` to optimize animations for performance.  
 

  10. Advanced CSS Frameworks & Preprocessors  

    - Modern CSS development often involves preprocessors like SCSS/SASS and frameworks like Tailwind CSS, Bootstrap, 
      and Material UI (MUI) to speed up styling and enhance maintainability.  

    - SCSS/SASS Basics: SCSS (Sassy CSS) and SASS (Syntactically Awesome Stylesheets) are CSS preprocessors that provide variables, 
      nesting, mixins, and functions to make CSS more modular and maintainable.  

      - SCSS uses curly braces (`{}`) like CSS.  
      - SASS (indented syntax) is whitespace-based (no `{}` or `;`).  

      - Variables (`$variable-name`): Define reusable values like colors, fonts, and sizes.  

        Example:  
          ```scss
          $primary-color: #ff5733;
          $font-size: 16px;

          button {
              background-color: $primary-color;
              font-size: $font-size;
          }
        
        - Easier theme customization.  

      - Nesting (Avoid Repetition): SCSS allows nested selectors to match HTML structure.  

        Example:  
          ```scss
          nav {
              ul {
                  list-style: none;
                  li {
                      display: inline-block;
                      a {
                          text-decoration: none;
                          color: black;
                      }
                  }
              }
          }
        
        - More readable than repeated selectors.  

      - Mixins (`@mixin` and `@include`): Reusable styles with parameters.  

        Example:  
          ```scss
          @mixin button-style($bg-color) {
              background-color: $bg-color;
              padding: 10px;
              border-radius: 5px;
          }

          button {
              @include button-style(blue);
          }
        
        - Avoids duplicate styles.  

      - Functions (`@function`): SCSS functions return computed values.  

        Example:  
        ```scss
          @function px-to-rem($px) {
              @return $px / 16 + rem;
          }

          p {
              font-size: px-to-rem(32);
          }
        
        - Creates dynamic, scalable values.  

    - Tailwind CSS (Utility-First Framework): Tailwind is a utility-first framework where you style elements directly in HTML.  

      - Installation:  
          npm install tailwindcss
          npx tailwindcss init

      - Utility Classes (No Custom CSS Needed!)  
        Example:  
        ```html
          <button class="bg-blue-500 text-white px-4 py-2 rounded">
              Click Me
          </button>
        
        - No need to write separate CSS files.  

      - Responsive Design (Mobile-First): Tailwind uses prefixes for responsive design.  

        | Prefix | Screen Size |
        |--------|------------|
        | `sm:` | `≥640px` |
        | `md:` | `≥768px` |
        | `lg:` | `≥1024px` |
        | `xl:` | `≥1280px` |

        Example:  
          ```html
          <div class="text-sm md:text-lg lg:text-2xl">Responsive Text</div>
          
        - Font size increases on larger screens.  

      - Customization (`tailwind.config.js`)  
        Example:  
          ```js
          module.exports = {
              theme: {
                  extend: {
                      colors: {
                          primary: "#ff5733",
                      },
                  },
              },
          };
        
        - Define custom colors, spacing, and fonts.  

    - Bootstrap CSS (Component-Based Framework): Bootstrap provides ready-made components and grid systems for rapid UI development.  

      - Installation:  
        npm install bootstrap
        
        or use CDN:  
          ```html
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
        

      - Bootstrap Grid System (12 Columns): Bootstrap uses flexbox-based grids for layout.  

        Example:  
          ```html
          <div class="container">
              <div class="row">
                  <div class="col-md-6">Half Width</div>
                  <div class="col-md-6">Half Width</div>
              </div>
          </div>
          ```
        - Responsive, flexible grid layout.  

      - Bootstrap Components: Bootstrap comes with prebuilt UI elements.  

        Example:  
          ```html
          <button class="btn btn-primary">Primary Button</button>
        
        - No need to write custom styles.  

      - Bootstrap Utilities (Spacing, Colors, etc.)  
        ```html
        <div class="p-3 bg-warning text-center">Warning Box</div>
        
        - Quick utility classes for styling.  

    - Material UI (MUI - Google’s Design System for React): Material UI provides React components following Google’s Material Design principles.  

      - Installation:  
          npm install @mui/material @emotion/react @emotion/styled

      - Importing MUI Components  
        Example:  
          ```jsx
          import { Button } from "@mui/material";

          function App() {
              return <Button variant="contained" color="primary">Click Me</Button>;
          }
          
        - Pre-styled components with built-in themes.  

      - Custom Themes in MUI  
        Example:  
          ```jsx
          import { createTheme, ThemeProvider } from "@mui/material/styles";

          const theme = createTheme({
              palette: {
                  primary: {
                      main: "#ff5733",
                  },
              },
          });

          function App() {
              return (
                  <ThemeProvider theme={theme}>
                      <Button variant="contained" color="primary">Styled Button</Button>
                  </ThemeProvider>
              );
          }
        
        - Easily customize colors, typography, and spacing.  

    - Final Thoughts  
      - SCSS/SASS: Write modular and maintainable CSS with variables, mixins, and functions.  
      - Tailwind CSS: Utility-first framework for rapid development.  
      - Bootstrap: Prebuilt components and a flexible grid system.  
      - Material UI (MUI): Google's Material Design for React apps.  


  11. CSS Performance Optimization Techniques  

    - Optimizing CSS ensures faster page loads, better performance, and a smoother user experience. Here are key techniques:  

    - Minification & Compression: CSS files contain extra spaces, comments, and redundant characters that increase file size.  

      - Minification (Removing Unnecessary Characters): Minification removes spaces, comments, and line breaks without affecting functionality.  

        Example:  
        - Before Minification (Readable)
            /* Stylesheet */
          body {
              background-color: #fff;
              font-size: 16px;
          }
          h1 {
              color: blue;
              margin-top: 20px;
          }

        - After Minification (Compressed)
          body{background-color:#fff;font-size:16px}h1{color:blue;margin-top:20px}
        
        - Reduces file size, improves loading speed.  

      - How to Minify CSS?
        - Online Tools: [CSS Minifier](https://cssminifier.com/)  
        - Build Tools:  
        - Webpack: `css-minimizer-webpack-plugin`  
        - Gulp: `gulp-cssnano`  
        - PostCSS: `cssnano`  

        - Example (Using PostCSS & cssnano in Webpack)
          ```js
          const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

          module.exports = {
              optimization: {
                  minimize: true,
                  minimizer: [new CssMinimizerPlugin()],
              },
          };

        - Automates minification in production builds.  

    - Critical CSS (Loading Above-the-Fold Styles First): Critical CSS renders above-the-fold content quickly, improving perceived performance.

      - Extracting Critical CSS: Instead of loading all CSS at once, load only essential styles first.

        - Example:
          ```html
          <style>
              body { font-family: Arial, sans-serif; }
              header { background-color: blue; color: white; padding: 10px; }
          </style>
        
        - Inline only essential styles in `<head>`, defer the rest.  

      - Automating Critical CSS Extraction
        - Use tools like:  
        - [`critical`](https://github.com/addyosmani/critical) (Node.js package)  
        - Google Chrome DevTools (`Coverage` tab to find unused CSS)  

        Example (Using `critical` in Node.js)
          ```js
          const critical = require('critical');

          critical.generate({
              inline: true,
              base: 'dist/',
              src: 'index.html',
              target: 'index.html',
              width: 1300,
              height: 900,
          });
        
        - Extracts & inlines only above-the-fold styles.  

    - Lazy Loading (`loading="lazy"`): Lazy loading defers loading images until they appear in the viewport, reducing initial load time.

      - Using `loading="lazy"` in Images
        Example:
        ```html
         <img src="large-image.jpg" alt="Lazy Loaded Image" loading="lazy">
        
        - Improves page speed by loading images only when needed.  

      - Lazy Loading Background Images (CSS): For background images, use JavaScript-based lazy loading.

        Example (Using `IntersectionObserver`)
          ```js
          document.addEventListener("DOMContentLoaded", function () {
              let lazyImages = document.querySelectorAll(".lazy-bg");

              let observer = new IntersectionObserver((entries, observer) => {
                  entries.forEach(entry => {
                      if (entry.isIntersecting) {
                          entry.target.style.backgroundImage = `url(${entry.target.dataset.bg})`;
                          observer.unobserve(entry.target);
                      }
                  });
              });

              lazyImages.forEach(img => observer.observe(img));
          });
        
        HTML:
          <div class="lazy-bg" data-bg="background.jpg"></div>
        
        - Lowers memory usage & improves performance.  

    - Avoiding `!important`: The `!important` rule overrides all specificity rules, making styles hard to debug and maintain.

      - When to Avoid `!important`
        ❌ Bad Practice
        ```css
          .button {
              background-color: red !important;
          }
        
        ✅ Better Approach (Use Higher Specificity)
        ```css
          .button.primary {
              background-color: red;
          }
        
        - Avoids conflicts & keeps styles manageable.  

    - Avoiding Too Many Reflows & Repaints: Reflows and repaints happen when the browser recalculates layouts, slowing performance.

      -  What Causes Reflows?
        Expensive operations:
        - Changing dimensions (width, height)
        - Adding/removing DOM elements
        - Applying `display: none`
        - Using `position: absolute` frequently

      - How to Reduce Reflows?
        - Use `visibility: hidden` instead of `display: none`
        ```css
        .hidden {
            visibility: hidden;
        }
        
        Why?
        ✅ `visibility: hidden` hides elements without triggering a reflow.  
        ❌ `display: none` removes elements, causing a reflow.

      - Use Efficient Animations (`transform` & `opacity`)
        - Use GPU-accelerated properties (`transform` & `opacity`)
        ```css
        .box {
            transform: translateX(100px); /* ✅ Good */
            opacity: 0.5; /* ✅ Good */
        }
        
        ❌ Avoid Animating `width`, `height`, `top`, or `left`  
        ```css
        .box {
            width: 200px; /* ❌ Causes reflow */
        }
        
        ✅ Tip: Use `will-change` for smoother animations.  

      - Batch DOM Updates (Avoid Frequent Layout Changes)
        ❌ Bad Practice
        ```js
        for (let i = 0; i < 100; i++) {
            document.querySelector(".box").style.width = i + "px";
        }
        
        ✅ Better Approach (Use `requestAnimationFrame`)
        ```js
        let box = document.querySelector(".box");
        requestAnimationFrame(() => {
            box.style.width = "200px";
        });
        
        - Reduces layout thrashing, improving performance.  

    - Final Optimization Checklist
      - Minify & compress CSS (Use `cssnano` or Webpack plugins).  
      - Extract & inline critical CSS (Use `critical` package).  
      - Lazy load images (`loading="lazy"` for images & `IntersectionObserver` for background images).  
      - Avoid `!important` (Use better specificity & structured CSS).  
      - Optimize rendering (Reduce reflows & use GPU-accelerated properties).  
        

  12. Accessibility (A11Y) & CSS Best Practices  
    - Making websites accessible ensures they work for everyone, including users with disabilities. Here are key accessibility techniques:  

    - `aria` Attributes (Accessible Rich Internet Applications): ARIA (Accessible Rich Internet Applications) attributes enhance 
      accessibility by providing extra information to screen readers and assistive technologies.

      - Common `aria` Attributes  

        | ARIA Attribute  | Purpose |
        |----------------|---------|
        | `aria-label` | Provides a label for elements without visible text. |
        | `aria-labelledby` | References another element's ID as a label. |
        | `aria-hidden="true"` | Hides elements from screen readers. |
        | `aria-disabled="true"` | Disables an element for assistive tech (instead of `disabled`). |
        | `aria-live="polite"` | Announces dynamic content changes. |
        | `role="alert"` | Marks an element as an important alert. |

      - Examples of ARIA Usage  

        - `aria-label` for Better Button Descriptions  
          ```html
          <button aria-label="Close the modal">❌</button>
          
          - Helps screen readers understand the button’s function.  

        - `aria-labelledby` for Form Fields  
          ```html
          <label id="email-label">Enter your email</label>
          <input type="email" aria-labelledby="email-label">
          
          - Connects the label and input for assistive tech.  

        - Hiding Decorative Elements (`aria-hidden`)  
          ```html
          <i class="icon-star" aria-hidden="true"></i>
          
          - Prevents unnecessary icons from being read aloud.  

        - Announcing Live Changes (`aria-live`)  
          ```html
          <div aria-live="polite">New notifications will appear here.</div>
          
          - Ensures updates are read automatically without disturbing the user.  

      - Why Not Just Use `display: none`?
        - `display: none;` hides elements from both sighted users and screen readers.  
        - `aria-hidden="true"` hides elements only from screen readers while keeping them visible.  
        - Use `aria-hidden="true"` for purely decorative elements.  

    - High Contrast Mode (For Visually Impaired Users): Some users enable high contrast mode in their OS for better readability.  

      - Detecting High Contrast Mode (`forced-colors`): Use the `@media (forced-colors: active)` query to adjust styles for high contrast mode.

        - Example:  
          ```css
          @media (forced-colors: active) {
              button {
                  background: transparent;
                  border: 2px solid ButtonText;
                  color: ButtonText;
              }
          }
        
          - Uses OS-defined contrast-friendly colors.  

      - Avoid Low-Contrast Colors  
        ❌ Bad Contrast (Hard to read)  
          ```css
          button {
              background-color: #f4f4f4;
              color: #bdbdbd;
          }
        
        ✅ Good Contrast (Better readability)  
          ```css
          button {
              background-color: #000;
              color: #fff;
          }
        
        - Use tools like [Contrast Checker](https://webaim.org/resources/contrastchecker/) to meet WCAG guidelines.  

    - Focus Indicators (`:focus-visible`): Focus indicators help keyboard users navigate websites without a mouse.

      - What is `:focus-visible`?  
        - `:focus` applies to all focusable elements, including clicks.  
        - `:focus-visible` applies only when keyboard users navigate (e.g., using `Tab`).  

        - Example:  
          ```css
          button:focus-visible {
              outline: 2px solid blue;
              box-shadow: 0 0 5px rgba(0, 0, 255, 0.5);
          }
        
        - Only shows focus styles for keyboard users, avoiding distractions for mouse users.  

      - Remove Default Focus Styles But Keep Accessibility
        ❌ Bad (Removes focus entirely!)  
          ```css
          button:focus {
              outline: none;
          }
        
        ✅ Better (Keeps accessible focus styles)  
          ```css
          button:focus {
              outline: 2px solid blue;
          }
        
        - Always provide a visible focus state!  

      - Styling Focus for High Visibility: Use contrasting colors and box shadows for better focus indicators.  

        Example:  
          ```css
          input:focus {
              outline: 3px solid #ff5733;
              background-color: #fff5f5;
          }
        
        - Easier to spot on the page.  

    - Final Accessibility Checklist
      - Use ARIA attributes to enhance accessibility.  
      - Ensure high contrast mode support (`forced-colors`).  
      - Provide clear, visible focus indicators (`:focus-visible`).  
      - Test with a screen reader (NVDA, VoiceOver, JAWS).  



Interview Questions:
--------------------------


  - What are the different types of CSS?  
    - Inline CSS: Applied directly to an element using the `style` attribute.  
    - Internal CSS: Defined inside a `<style>` tag within an HTML document.  
    - External CSS: Written in a separate `.css` file and linked to the HTML file using `<link>`.

  - What is the difference between `id` and `class` in CSS?  
    - `id` is unique and used for a single element (`#idname`).  
    - `class` can be applied to multiple elements (`.classname`).

  - What are pseudo-classes in CSS?  
    - Pseudo-classes define the special state of an element. Examples:  
      - `:hover` (when a user hovers over an element)  
      - `:focus` (when an element is focused)  
      - `:nth-child(n)` (targets a specific child element)

  - What is the difference between `relative`, `absolute`, and `fixed` positioning in CSS?  
    - Relative: Positioned relative to its normal position.  
    - Absolute: Positioned relative to its nearest positioned ancestor (or `body` if none).  
    - Fixed: Positioned relative to the viewport and does not move when scrolling.

  - What is Flexbox, and how does it work?  
    - Flexbox is a layout model for one-dimensional layouts. It is defined using `display: flex;` and provides properties like:  
      - `justify-content` (aligns items horizontally)  
      - `align-items` (aligns items vertically)  
      - `flex-wrap` (wraps items to the next row/column)  

  - How is Grid different from Flexbox?  
    - Flexbox is a one-dimensional layout system (row or column).  
    - CSS Grid is a two-dimensional system (both rows and columns).

  - What is the difference between `em`, `rem`, `%`, `px`, and `vh/vw` units in CSS?  
    - `px` (pixels) - Fixed size.  
    - `%` - Relative to the parent element.  
    - `em` - Relative to the font size of the parent element.  
    - `rem` - Relative to the root element (`html`).  
    - `vh/vw` - Relative to the viewport height and width.

  - What are media queries in CSS?  
     Media queries allow responsive design based on screen size. Example:  
      ```css
      @media (max-width: 600px) {
          body {
              background-color: lightblue;
          }
      }

  - What is the difference between `min-width`, `max-width`, and `width` in CSS?  
    - `width`: Defines a fixed width.  
    - `min-width`: Ensures an element doesn’t shrink below a certain width.  
    - `max-width`: Ensures an element doesn’t grow beyond a certain width.

  - How does `z-index` work in CSS?  
    - `z-index` controls the stack order of overlapping elements. Higher values appear on top. Example:  
      ```css
      .box1 { z-index: 1; }
      .box2 { z-index: 2; } /* Will be on top */

  - What are pseudo-elements in CSS?  
    - Pseudo-elements allow styling a part of an element. Example:  
      - `::before` (inserts content before an element)  
      - `::after` (inserts content after an element)  
      ```css
      p::before { content: "Hello "; }

  - What is the difference between `visibility: hidden` and `display: none`?  
    - `visibility: hidden;` hides the element but keeps its space.  
    - `display: none;` removes the element from the document flow.

  - How does CSS `clip-path` work?  
    - It clips an element to a specified shape. Example:  
      ```css
      img {
          clip-path: circle(50%);
      }

  - What is the difference between `grid-template-areas` and `grid-template-columns/rows`?  
    - `grid-template-columns/rows` define the number of columns and rows.  
    - `grid-template-areas` assigns names to grid sections for easier layout control.

  - What is the difference between `@import` and `<link>` for adding CSS?  
    - `<link>` is preferred for performance as it loads in parallel.  
    - `@import` is processed after the page loads and can slow down rendering.

  - How do you create a CSS-only dropdown menu?  
    - Using `:hover`:  
      ```css
      .dropdown:hover .menu {
          display: block;
      }

  - What is the difference between `will-change` and `translateZ(0)` for performance optimization?  
    - `will-change` hints to the browser about future animations.  
    - `translateZ(0)` forces GPU acceleration.

  - What is `object-fit` and `object-position` in CSS?  
    - `object-fit` controls how an image fits inside a container.  
    - `object-position` controls the position of the image inside the container.  
      ```css
      img {
          object-fit: cover;
          object-position: center;
      }

  - How do CSS variables work?  
    - CSS variables allow reusability:  
      ```css
      :root {
          --main-color: blue;
      }
      p {
          color: var(--main-color);
      }
