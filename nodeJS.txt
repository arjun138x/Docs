Nodejs
-------
  Getting Started with Node 
  -------------------------
    > Node is a runtime environment for executing JS code.
    > Essentially, Node is a C++ program that embeds Chrome’s v8 engine, the fastest
      JS engine in the world.
    > We use Node to build fast and scalable networking applications. It’s a perfect
      choice for building RESTful services.
    > Node applications are single-threaded. That means a single thread is used to
      serve all clients.
    > Node applications are asynchronous or non-blocking by default. That means
      when the application involves I/O operations (eg accessing the file system or the
      network), the thread doesn’t wait (or block) for the result of the operation. It is
      released to serve other clients.
    > This architecture makes Node ideal for building I/O-intensive applications.
    > You should avoid using Node for CPU-intensive applications, such as a video
      encoding service. Because while executing these operations, other clients have
      to wait for the single thread to finish its job and be ready to serve them.
    > In Node, we don’t have browser environment objects such as window or the
      document object. Instead, we have other objects that are not available in
      browsers, such as objects for working with the file system, network, operating
      system, etc.

  Node Core 
  ---------

    > We don’t have the window object in Node.
    > The global object in Node is “global”.
    > Unlike browser applications, variables we define are not added to the “global”
      object.
    > Every file in a Node application is a module. Node automatically wraps the code
      in each file with an IIFE (Immediately-invoked Function Expression) to create
      scope. So, variables and functions defined in one file are only scoped to that file
      and not visible to other files unless explicitly exported.
        > 
    > To export a variable or function from a module, you need to add them to
      module.exports:
      module.exports.sayHello = sayHello;
    > To load a module, use the require function. This function returns the
      module.exports object exported from the target module:
      const logger = require(‘./logger’);
    > Node has a few built-in modules that enable us to work with the file system, path
      objects, network, operating system, etc.
    > EventEmitter is one of the core classes in Node that allows us to raise (emit) and
      handle events. Several built-in classes in Node derive from EventEmitter.
    > To create a class with the ability to raise events, we should extend EventEmitter:
      class Logger extends EventEmitter {
      } 


javaScript Fundamental concepts
--------------------------------
  Introduction
  ------------
    > javaScript is a scripting language used both on client-side and server-side, that allows you to make web pages interactive. 

    > ONLINE CODEPLAYGROUND :  > https://playcode.io
    
    > ONLINE CODEPLAYGROUND :  > https://playcode.ioVariable Declaration
      > var a=10, let & const introduced in ES6 

    > Data types
      > 1. number // numeric or decimal
        2. string
        3. boolean
        4. undefined  these are all the actual data types
      > var a=10;
        console.log(typeof(a)) ==> number

    > Arrays and Objects
      var data=[1,2,3,4,5] ==> Array
      var data={"key":"value"} ==> Object

    > Functions
      function user(a){
        console.log(a+1)
      }
      user(10) ==> 11

    > Conditional Statement
      > if, else if, else, switch
      var a=10;
      if (a>5){
        console.log(a)
      }

    > Looping concept
      > for, while
      > for( var i=1; i<5;i++){
          console.log(i)
        }

      > var a=0;
        while(a<5){
          a+=1;
          console.log(a)
        }


ES5 to ES12 ECMAScript 2021 
----------------------------
  
  ES5 Version
  -----------

    > Array features
    -----------------
      > isArray()
        > var data = [1,2,3]
          console.log(Array.isArray(data)) ==> true

      > map()
        > It is similar to for forEach but forEach does not return Array
        > var data = [1,2,3]
          var output = data.map(function(a){  // var output = data.map((a)=>a*a)
            return a*a
          })
          console.log(output)

      > filter()
        > var data = [1,2,3]
          var output = data.filter(function(a){   // var output = data.filter((a)=>a>=2)
            return a>=2
          })
          console.log(output)

      > forEach() // It return true or false
        > var data = [1,2,3]
          data.forEach((a)=>{
            console.log(a*a)
          })

      > every() // It return true or false
        > var data = [1,2,3]
          var output = data.every((a)=>a>1)
          console.log(output) ==> false // All values in the Array should be satisfy the given condition other wise it return false

      > some()  // It return true or false
        > var data = [1,2,3]
          var output = data.some((a)=>a>1)
          console.log(output)  ==> true // At least one value of Array need to satisfy the condition

      > indexOf() // it return first index value  
        > var data = [1,2,3,2]
          console.log(data.indexOf(2)) 

      > lastIndexOf() // it return last index value  
        > var data = [1,2,3,2]
          console.log(data.lastIndexOf(2)) 
          

    > JSON features
    -----------------
      > stringfy() // It converts Object to string
        var data = {
          name : 'john',
          age : 32
        }
        var json = JSON.stringify(data)
        console.log(typeof(json))
      

    > Date features
    -----------------
      > valueOf()
        var date = new Date();
        console.log(date)
        console.log(date.valueOf())


  ES6 / ECMAScript 2015
  ---------------------
    > let & const
      > var keyword has global scope but let & const don't
        {
          var a=12
        }
        console.log(a) 

      > The const keyword specifies that a variable's value is constant and tells the compiler to prevent 
      the programmer from modifying it. Let & Constants are block-scoped.
        const a=10;
        a = 20;
        console.log(a)

    > Arrow Functions
      > Arrow function are advanced version of functions
      > Functions are not going to be changed so all functions we declare by const keyword
        > Normal Function
          const user = function(name){
            console.log(`hi ${name}`)
          }
          user("john");
        
        > Arrow Function
          > const user =(name)=>{console.log(`hi ${name}`)}
            user("john"); 

    > Classes
      > class User{
          constructor(pass){
          this.pass=pass    // this keyword refers to an object or current Object(we can define more then one object for one class)
        }
          user(name){
            console.log(this.pass)
            console.log(`Hi ${name}`)
          }
        }
        let obj = new User()
        obj.user('John')
        let obj2 = new User(9876543)
        obj2.user('John')
          

    > For..of // it is similar to for loop
      > let arr=[1,2,3,4,5,6,7]
        for(const a of arr){
          console.log(a)
        }

    > Default Parameter
      > function user(name="john"){
          console.log(name)
        }
        user()

    > Rest Operator   // It is used to fetch remaining values 
      > function user(name, ...x){  // Rest Operator(...) always in last
          console.log(x)
        }
        user('john',123,'john@gmail.com')

    > Spread Operator 
      > let arr1=[1,2,3]
        let arr2=[4,5,6]
        let arr3=[...arr1,...arr2]    // this is not Destructuring
        console.log(arr3)

    > Destructuring 
      > let user={
          name:'john',
          mail:'john@gmail.com'
        }
        const {name,mail}=user
        console.log(name)
        console.log(user.name)


  ES7 / ECMAScript 2016
  ---------------------
    > Exponentiation Operator   // it is all about x power y (x**y)
      > console.log(2**3)

    > Includes()
      > let user=[1,2,3,4]
        console.log(user.includes(2))


  ES8 / ECMAScript 2017
  ---------------------
    > padStart()
      > let data="hello"
        console.log(data.padStart(10,"*"))

    > padEnd()
      > let data="hello"
        console.log(data.padEnd(10,"*"))

    > Object.entries // It stores data like arrays of array
      > let data={
          name:"john",
          age:31,
          mail:"john@gmail.com"
        }
        console.log(JSON.stringify(Object.entries(data)))   // [["name","john"],["age",31],["mail","john@gmail.com"]]

    > Object.values   // it return only values
      > let data={
          name:"john",
          age:31,
          mail:"john@gmail.com"
        }
        console.log(Object.values(data))  // ["john",31,"john@gmail.com"]
        console.log(Object.keys(data))    // ["name","age","mail"]

    > Async/Await 
      > Asynchronous is called Non-Blocking
      > The Async... Await syntax in ES6 use to handle the http promises requests.

      > const url="https://playcode.io/new/"
        const response = fetch(url)
          .then(response =>{
            console.log(response.data)
          })
        console.log(12) 


  ES9 / ECMAScript 2018
  ---------------------
    > Regular Expression Improvements
      let data = 'hello user 1234'
      console.log(data.match(/llO/i))   // i means ignore the case 
      console.log(data.match(/[a-z]/g))   // g means global
      console.log(data.match(/[0-9]/g))   // [0-9] mean it return numbers only
      console.log(data.match(/[ ]/g)) 
      console.log(data.match(/[^0-9 ]/g))   // ^ means not Operator

    > Rest/Spread Properties (arguments can be transferred to a function)
      > let data = [1,2,3,4,5]
        console.log(Math.max(...data))
    

  ES10 / ECMAScript 2019
  ---------------------
    > Flat    // nested array converts as flat
      > let data = [1,2,3,[4,5,[6,7,8]],[9]]
        console.log(data.flat(1))

    > Function.toString
      > function user(){
          console.log(123)
        }
        console.log(user.toString())

    > trimStart
      > let data = "  hello  "
        console.log(data.trimStart())

    > trimEnd
      > let data = "  hello  "
        console.log(data.trimEnd())

    > Object.fromEntries  // converts array into Object
      > let data = [['name','john'],['age',32]]
        console.log(Object.fromEntries(data))


  ES11 / ECMAScript 2020
  ---------------------
      > BigInt (Number.MAX_SAFE_INTEGER)
        2**53 -1 = 9007199254740991

      > Dynamic Import  // we can import if we needed it
        > async()=>{
            const module = await import("module.js")
          }

      > Nullish operator    // ??
        > let data = null
          let output=data ?? 'john'   // if data is null then it return 'john'
          console.log(output)

      > Optional Chaining  
        > Optional chaining is a safe way to access nested object properties, even if the property does not exist.
        > let pet ={
            cat:{
              name:"neo"
            }
          }
          alert(pet.dog.name)
          alert(pet.dog?.name)
          alert(pet.dog && pet.dog.name)  // before Optional Chaining method we write code like this

        > let user ={
            admin(){
              console.log('I am from admin method')
            }
          }
          user.admin?.()
        
        > const a = ["value1"];
          console.log(a?.[1]?.[0]); // undefined 


  ES12 / ECMAScript 2021
  ---------------------
    > String.prototype.replaceAll()
      > let data = 'JavaScript'
        console.log(data.replaceAll('a','0'))

    > Numeric Separators
      let data = 10_50_1
      console.log(data)   // 10501

    > Logical Assignment Operators (&&=, ||=)
      > let arr1 = 10;
        let arr2 = 20;
        arr2 &&= arr1   // && it checks the left side value is true or false. if it is true it execute the right side value 
        console.log(arr2)

        arr1 = 10;
        arr2 = 20;
        arr2 ||= arr1
        console.log(arr2)


Callbacks, Promises, Async-Await
---------------------
  > in Nodejs we have only callback and promises

  // Sync code
    function print(string) {
      console.log(string);
    }

    print("Start");
    print("Printing something");
    print("Finish");

  // Async code
    function print(string) {
      setTimeout(() => {
        console.log(string);
      }, Math.floor(Math.random() * 100));
    }

    print("Start");
    print("Printing something");
    print("Finish");

  // Callback
    function print(string, callback) {
      setTimeout(() => {
        console.log(string);
        callback();
      }, Math.floor(Math.random() * 100));
    }

    print("Start", () => {
      print("Printing something", () => {
        print("Finish", () => {});
      });
    });

  // Promise   === A Promise has 3 states Pending, Resolve, Reject
    function print(string) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(string);
          resolve();
        }, Math.floor(Math.random() * 100));
      });
    }

    print("Start")
      .then(() => print("Printing something"))
      .then(() => print("Finish"));

  // Promise   === A Promise has 3 states Pending, Resolve, Reject
    function print(string) {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(string);
          resolve();
        }, Math.floor(Math.random() * 100));
      });
    }

    async function startAll() {
      await print("Start");
      await print("Printing something");
      await print("Finish");
    }
    startAll();


JavaScript OOPS
---------------
  > Benefits of OOPS
    > Reuse of code through inheritance 
    > Flexibility through polymorphism 
    > Easier to troubleshoot(find errors)
    > Code maintainability

  > Abstraction 
    > An abstraction is a way of hiding the implementation details and showing only the functionality to the users. 
      In other words, it ignores the irrelevant details and shows only the required one.
      Ex :  > ATM( it gives the money but it didn't show the background process)
    
    > class Atm{
        constructor(withdraw){  // A constructor is a special function that creates and initializes an object instance of a class
          this.balance = 1000
          this.withdraw= withdraw
        }
        getAmount(){
          let minimum = 500 // user can't modify this. this is abstraction
          if(this.balance-this.withdraw>=this.minimum){
            console.log("Transaction successful")
          }
          else{
            console.log("Transaction failed")
          }
        }
      }

      let obj = new Atm(500)
      console.log(obj.minimum)
      obj.getAmount()


  > Encapsulation 
    > Encapsulation in JavaScript is a process of binding the data with the functions which act upon the data. 
      Encapsulation allows us to control and validate the data

    > It is Mechanism of bundling data variables and methods together & hides them from other classes.

    > class Person{
        constructor(name,age,salary){
          this.name=name
          this.age=age
          this.salary=salary
        }
        
        getName(){
          console.log(this.name)
        }
        getAge(){
          console.log(this.age)
        }
        getSalary(){
          console.log(this.salary)
        }
      }

      let obj = new Person("John",31,30000)
      obj.getName()
      obj.getAge()
      obj.getSalary()
       

  > Inheritance
    > Inheritance is the procedure in which one class inherits the attributes and methods of another class
    > class Parent{
        getUser(){
          console.log("user")
        }
      }
      class Child extends Parent{

      }

      let obj = new Child()
      obj.getUser()


  > Polymorphism
    > poly(many) + morph(form) = Many Forms 
    > Polymorphism allows us to perform a single action in different ways.
      > class Parent{
          getMobile(){
            console.log("mobile 1")
          }
        }
        class Child extends Parent{
          getMobile(){
            console.log("mobile 2")
          }
        }

        let obj = new Child()
        obj.getMobile()


Closure
-------
  > Closure is a feature in JavaScript where an inner function has access to the outer function's variables and parameters     >  > a scope chain
    > 1. it has access to the it's own scope
      2. it has access to the outer functions variables
      3. it has access to the global variables
  > A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). 
  In other words, a closure gives you access to an outer function's scope from an inner function.
    var x=100
    function outer() {
        var y=50
        var n=500
        function inner() {
            var z=10
            console.log(y+z); // hear we are trying to access "y" it is in another function
            y++
            z++

        }
        return inner
    }
    let inner=outer(); // after calling the outer() function the "y" scope will destroy. in below line we are calling (inner). hear we are accessing "y" value. in this place closer come to the picture.
    console.log(inner()); // 
    console.dir(inner); //  you can increase the the y value but you can't increase z value. after calling inner() "z" scope will destroy
    console.log(inner()); // 
    /* 
    if u run this in browser. inside [[Scopes]]==> Closure (outer) ==> y : 50 
    but you didn't get "n" value in Closure. Closure will stores used variables only
    */
    

Regular expressions
----------------
  > Regular expressions are a powerful tool used for pattern matching and manipulation in strings. 
    There are various types of regular expressions based on the characters and syntax used.

  1. Literal Characters:
    - Matching specific characters as they appear in the pattern.
    - Example: `hello` matches the word "hello" in the input text.

    > const text = "The quick brown fox jumps over the lazy dog";
      const pattern = /fox/;

      const result = pattern.test(text);
      console.log(result); // Output: true


  2. Character Classes:
    - Matching any one of a set of characters.
    - Example: `[aeiou]` matches any lowercase vowel.

    > const text = "The quick brown fox jumps over the lazy dog";
      const pattern = /[aeiou]/g;

      const matches = text.match(pattern);
      console.log(matches); // Output: [ 'e', 'u', 'i', 'o', 'o', 'u', 'o', 'e', 'a', 'u' ]


  3. Negated Character Classes:
    - Matching any character that is not in a specific set.
    - Example: `[^0-9]` matches any non-digit character.

    > const text = "The quick brown fox";
      const pattern = /[^aeiou]/g;

      const matches = text.match(pattern);
      console.log(matches); // Output: [ 'T', 'h', ' ', 'q', 'c', 'k', ' ', 'b', 'r', 'w', 'n', ' ', 'f', 'x']


  4. Ranges:
    - Matching any character within a specified range.
    - Example: `[a-z]` matches any lowercase letter.

    > const text = "The quick brown fox";
      const pattern = /[a-z]/g;

      const matches = text.match(pattern);
      console.log(matches); // Output: [ 'h', 'e', 'q', 'u', 'i', 'c', 'k', 'b', 'r', 'o', 'w', 'n', 'f', 'o', 'x']


  5. Wildcard:
    - Matching any single character (except newline).
    - Example: `.` matches any character except a newline.

    > const text = "The quick brown fox jumps over the lazy dog";
      const pattern = /o./g;

      const matches = text.match(pattern);
      console.log(matches); // Output: [ 'ow', 'ox', 'ov' ]


  6. Quantifiers:
    - Specifying how many times a character or group should occur.
    - Examples:
      - `*`: Matches zero or more occurrences.
        > const text = "abbcccddddeeeee";
          const pattern = /b*/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'b', '', '', '', '', '' ]

      - `+`: Matches one or more occurrences.
        > const text = "abbcccddddeeeee";
          const pattern = /c+/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'ccc' ]

      - `?`: Matches zero or one occurrence.
        > const text = "abbcccddddeeeee";
          const pattern = /d?/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ '', '', '', 'd', '', '', '', '', '' ]

      - `{n}`: Matches exactly n occurrences.
        > const text = "abbcccddddeeeee";
          const pattern = /e{3}/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'eee' ]

      - `{n,}`: Matches n or more occurrences.
        > const text = "abbcccddddeeeee";
          const pattern = /e{3}/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'eee' ]

      - `{n,m}`: Matches at least n and at most m occurrences.
        > const text = "abbcccddddeeeee";
          const pattern = /d{2,4}/g;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'dddd' ]


  7. Anchors:
    - Specifying the position in the input text where a match should occur.
    - Examples:
      - `^`: Matches the start of a line.
        > const text = "The quick brown fox\njumps over the lazy dog";
          const pattern = /^The/g;

          const result = pattern.test(text);
          console.log(result); // Output: true

      - `$`: Matches the end of a line.
        > const text = "The quick brown fox\njumps over the lazy dog";
          const pattern = /dog$/g;

          const result = pattern.test(text);
          console.log(result); // Output: true
      
      - Using m flag for multiline matching:

        > const text = "The quick brown fox\njumps over the lazy dog";
          const pattern = /^The/gm;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'The' ]
          
          > In this example, the regular expression /^The/gm matches the word "The" at the start of the first line 
            because of the m flag (multiline). Without the m flag, it would have only matched 
            "The" at the start of the whole text, not individual lines.

      - Using m flag to match the end of each line:

        > const text = "The quick brown fox\njumps over the lazy dog";
          const pattern = /dog$/gm;

          const matches = text.match(pattern);
          console.log(matches); // Output: [ 'dog' ]
          
          > In this example, the regular expression /dog$/gm matches the word "dog" at the end of the last line because of the m flag (multiline).

          > The m flag is used to enable multiline matching, allowing the anchors to work on each line independently.


  8. Grouping and Capturing:
    - Grouping parts of the pattern together.
    - Capturing and extracting parts of the matched text.
    - Example: `(\d{2})-(\d{2})-(\d{4})` captures a date pattern like "12-31-2023" as three groups: "12", "31", and "2023".

    > const text = "My phone number is 123-456-7890";
      const pattern = /(\d{3})-(\d{3})-(\d{4})/;

      const match = pattern.exec(text);
      console.log(match[0]); // Output: 123-456-7890
      console.log(match[1]); // Output: 123
      console.log(match[2]); // Output: 456
      console.log(match[3]); // Output: 7890

  9. Alternation:
    - Matching one pattern or another.
    - Example: `cat|dog` matches either "cat" or "dog" in the input text.

    > const text = "I have a cat and a dog";
      const pattern = /cat|dog/;

      const matches = text.match(pattern);
      console.log(matches); // Output: [ 'cat', 'dog' ]


  10. Escape Sequences:
    - Using backslashes to escape special characters and treat them as literal characters.
    - Example: `\.` matches a literal dot (period) in the input text.

    > const text = "I have a dot: .";
      const pattern = /\./;

      const result = pattern.test(text);
      console.log(result); // Output: true


Child process
---------------
  > Node.js Child Processes allow you to spawn new processes in your Node.js applications, which can run 
    independently of the main Node.js process. This is useful for various purposes, such as running 
    external commands, parallelizing tasks, or executing CPU-intensive operations without blocking the main event loop.

  > There are three main ways to create child processes in Node.js:

    > 1.child_process.spawn(): This method is used to spawn a new process and provides a way to 
        interact with its input and output streams. It is well-suited for long-running processes 
        that produce a continuous stream of data.

      > Example 1: Using spawn()
        > In this example, we use `spawn()` to run the `ls -lh /usr` command and listen for its standard output 
          and standard error streams.


        const { spawn } = require('child_process');

        // Spawn a child process to list files in the current directory
        const ls = spawn('ls', ['-lh', '/usr']);

        // Listen for data events from the child process
        ls.stdout.on('data', (data) => {
          console.log(`stdout: ${data}`);
        });

        ls.stderr.on('data', (data) => {
          console.error(`stderr: ${data}`);
        });

        // Handle the child process exit event
        ls.on('close', (code) => {
          console.log(`Child process exited with code ${code}`);
        });

    
    > 2.child_process.exec(): This method is used to run a shell command and buffers the command's output for you to use. 
        It's suitable for simple commands with a small amount of output.

      > Example 1: Using exec()
        > Here, we use `exec()` to run the `echo` command and capture its output and errors.

        const { exec } = require('child_process');

        // Execute a simple shell command
        exec('echo "Hello, Node.js"', (error, stdout, stderr) => {
          if (error) {
            console.error(`Error: ${error.message}`);
            return;
          }
          console.log(`stdout: ${stdout}`);
          console.error(`stderr: ${stderr}`);
        });
        ```


    > 3.child_process.fork(): This method is a specialized version of `spawn()` designed specifically for 
        creating new Node.js processes. It allows you to communicate between the parent and child processes 
        using inter-process communication (IPC).

      > In this example, we use `fork()` to create a child process that runs a separate Node.js script (`child.js`). 
        The parent and child processes communicate with each other using message passing through the 
        `process.send()` and `process.on('message', ...)` methods.

      > Example 3: Using `fork()`

        const { fork } = require('child_process');

        // Create a child process using fork
        const childProcess = fork('child.js');

        // Send a message to the child process
        childProcess.send({ message: 'Hello from the parent process!' });

        // Listen for messages from the child process
        childProcess.on('message', (message) => {
          console.log(`Parent received message: ${JSON.stringify(message)}`);
        });

      > Child Process (`child.js`):

        // Listen for messages from the parent process
        process.on('message', (message) => {
          console.log(`Child received message: ${JSON.stringify(message)}`);

          // Send a message back to the parent process
          process.send({ message: 'Hello from the child process!' });
        });


built-in node modules in nodejs
---------------------------------
  > Node.js provides a set of built-in modules that are available for use in your JavaScript applications. 
    These modules cover a wide range of functionality, from file system operations to networking and more. 
    here are some of the commonly used built-in Node.js modules:

    1. fs (File System): This module allows you to work with the file system, including reading and writing files, 
      creating and deleting directories, and more.

    2. http/https: These modules enable you to create HTTP and HTTPS servers and make HTTP requests. 
      They are fundamental for building web applications and APIs.

    3. url: The `url` module provides utilities for URL parsing and formatting, making it easier to work with URLs.

    4. path: This module offers utilities for working with file and directory paths. 
      It's particularly useful for ensuring cross-platform compatibility when dealing with file paths.

    5. events: The `events` module allows you to create and handle custom events, 
      which is crucial for building event-driven applications.

    6. util: The `util` module provides various utility functions and objects that can be helpful 
      in various scenarios, such as working with objects and inheritance.

    7. os (Operating System): This module provides information about the host operating system, 
      including CPU architecture, network interfaces, and more.

    8. querystring: The `querystring` module is used for parsing and formatting URL query strings.

    9. crypto: This module offers cryptographic functionality, including hashing, encryption, and decryption.

    10. child_process: This module allows you to create and interact with child processes, 
      which can be used for running external commands or parallelizing tasks.

    11. stream: The `stream` module provides a way to work with streams of data, allowing you to read and write data efficiently.

    12. zlib: This module provides compression and decompression capabilities, which can be useful when working with compressed data.

    13. events: The `events` module is used to create and handle custom events in your Node.js applications.

    14. assert: The `assert` module provides functions for performing assertions, which are useful for testing and debugging your code.

    15. os: The `os` module provides information about the operating system on which your Node.js application is running.

    16. process: The `process` module allows you to interact with the current Node.js process and control its behavior.

    17. url: The `url` module provides utilities for working with URLs, including parsing and formatting.

    18. querystring: The `querystring` module is used for parsing and formatting URL query strings.

    19. timers: This module contains functions for scheduling and executing code at specific intervals using timers.

    20. util: The `util` module provides various utility functions, such as formatting strings and working with objects.

 


---------------
INTERMEDIATE JS
---------------

  > spread operator 

    > The spread operator in Node.js (and JavaScript in general) is denoted by three dots (`...`) 
      and is used to spread the elements of an iterable (like an array or a string) into individual elements. 
      It's a versatile tool that allows you to manipulate arrays, function arguments, and object properties 
      in a concise and powerful way.

      > 1. Array Manipulation:
        > You can use the spread operator to create a new array by combining elements from existing arrays:
        > const array1 = [1, 2, 3];
          const array2 = [4, 5, 6];
          const combinedArray = [...array1, ...array2];
          console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

      > 2. Function Arguments:
        > When calling a function, you can use the spread operator to pass elements of an array as individual arguments to the function:
        > function addNumbers(a, b, c) {
            return a + b + c;
          }
          const numbers = [1, 2, 3];
          const result = addNumbers(...numbers);
          console.log(result); // 6
      
      > 3. Object Manipulation:
        > The spread operator can also be used to create a new object by copying properties from an existing object and/or adding new properties:
        > const obj1 = { a: 1, b: 2 };
          const obj2 = { c: 3, d: 4 };
          const combinedObject = { ...obj1, ...obj2, e: 5 };
          console.log(combinedObject); // { a: 1, b: 2, c: 3, d: 4, e: 5 }
          
      > It's important to note that the spread operator creates shallow copies. 
        This means that for nested objects or arrays, only the references are copied, not the actual objects themselves.

  > rest operator
    > The rest operator in Node.js (and JavaScript in general) is also denoted by three dots (`...`), 
      similar to the spread operator. However, its usage and purpose are different. 
      The rest operator is used in function parameters to collect the remaining arguments into a single array. 
      This can be very useful when you have a function that accepts a variable number of arguments.

      > function sum(...numbers) {
          return numbers.reduce((total, num) => total + num, 0);
        }
        const result = sum(1, 2, 3, 4, 5);
        console.log(result); // 15

        > In the example above, the `sum` function uses the rest operator `...numbers` in its parameter list. 
          This allows you to pass any number of arguments to the function, and they will be collected into the 
          `numbers` array inside the function. The `reduce` method is then used to sum up the values.

    > The rest operator can also be used to gather the remaining elements of an array into a new array:

      > const [first, second, ...rest] = [1, 2, 3, 4, 5];
        console.log(first); // 1
        console.log(second); // 2
        console.log(rest); // [3, 4, 5]

        > In this example, the rest operator is used to capture the remaining elements of the array into the `rest` array variable.

  > To summarize, the spread operator is used to spread elements from an iterable (like an array or a string), 
    whereas the rest operator is used to collect elements into an array, typically in the context of 
    function parameters or array destructuring. Both operators are powerful tools that help make your 
    code more flexible and expressive.

  > Default parameters
    > Default parameters in Node.js (and JavaScript in general) allow you to specify default values for function parameters. 
      If a parameter is not explicitly passed when calling the function, its default value will be used instead. 
      This can be especially useful for ensuring that your functions behave predictably even if certain arguments are missing.

      > function greet(name = 'Guest') {
          console.log(`Hello, ${name}!`);
        }
        greet();         // Output: Hello, Guest!
        greet('Alice');  // Output: Hello, Alice!

      > In this example, the greet function has a default parameter name set to 'Guest'. If you call the function 
        without passing any arguments, the default value will be used.

  > 










